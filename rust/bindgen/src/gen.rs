use crate::{
  clang,
  parse::Parser,
  cargo::{
    rerun_if_env_changed,
    rerun_if_path_changed,
  },
  util::callback::{
    Transform,
    TryMap,
  },
};

use std::{
  error::Error,
  fs::File,
  io::Write,
  path::PathBuf,
  process::Command,
};

use bindgen::{
  Bindings,
  Builder,
};

pub type BoxError = Box<dyn Error>;
pub type BoxResult<T> = Result<T, BoxError>;

pub struct Generator<'a> {
  pub parser: Parser<'a>,
  pub setup: Transform<'a, Builder>,
  pub postproc: TryMap<'a, PathBuf, BoxError>,
  pub header: PathBuf,
  pub output_name: String,
  pub output_dir: PathBuf,
  pub output_prefix: Vec<String>,
  pub output_suffix: Vec<String>,
  pub prog_src_dir: PathBuf,
  pub sol_root_dir: PathBuf,
  pub std: Option<String>,
  pub sysroot: Option<PathBuf>,
  pub define_bpf: bool,
  pub is_sol_test: bool,
  pub wall: bool,
  pub werror: bool,
  pub wextra: bool,
  pub wconversion: bool,
  pub nobuiltin: bool,
  pub keep_inline_funcs: bool,
  pub test_layout: bool,
  pub ignore_casing: bool,
}

impl<'a> Default for Generator<'a> {
  fn default() -> Self {
    Self{
      parser: Default::default(),
      setup: Default::default(),
      postproc: Default::default(),
      header: "bindings.h".into(),
      output_name: "bindings.rs".into(),
      output_dir: "src".into(),
      output_prefix: Default::default(),
      output_suffix: Default::default(),
      prog_src_dir: "../program/src".into(),
      sol_root_dir: "../../solana".into(),
      sysroot: None,  // derive from sol dir
      std: None,
      define_bpf: true,
      is_sol_test: false,
      wall: true,
      werror: true,
      wextra: true,
      wconversion: true,
      nobuiltin: true, // bpf.mk default
      keep_inline_funcs: false,
      test_layout: true,
      ignore_casing: true,
    }
  }
}

impl<'a> Generator<'a> {

  pub fn run(&self) -> BoxResult<()> {

    let builder = self.builder();
    let args = builder.command_line_flags();
    eprintln!("bindgen args:\n\t{}", args.join(" \\\n\t"));

    let bindings = self.gen_bindings()?;
    let out_path = self.write_bindings(bindings)?;

    rerun_if_path_changed(&self.header);
    rerun_if_path_changed(&out_path);

    // https://docs.rs/bindgen/latest/bindgen/struct.Builder.html#clang-arguments
    rerun_if_env_changed("BINDGEN_EXTRA_CLANG_ARGS");

    Ok(())
  }

  pub fn builder(&self) -> Builder {
    let mut builder = {
      Builder::default()
        .header(self.header.to_str().unwrap())
        .generate_inline_functions(self.keep_inline_funcs)
        .clang_args(self.clang_args().iter())
        .parse_callbacks(self.parser.boxed())
        .derive_default(true)
        .layout_tests(self.test_layout)

        // Disambiguate types generated by 'typedef struct foo { ... } foo_t'.
        // With c_naming, foo_t aliases 'struct_foo'.
        .c_naming(true)

        // C code should already prefix global enum member names.
        // Don't add an additional 'enum_myenum_' prefix.
        .prepend_enum_name(false)
    };
    if self.test_layout {
      builder = builder.raw_line("#![allow(deref_nullptr)]");
    }
    if self.ignore_casing {
      builder = builder.raw_line("#![allow(non_upper_case_globals)]");
      builder = builder.raw_line("#![allow(non_camel_case_types)]");
      builder = builder.raw_line("#![allow(non_snake_case)]");
    }
    for line in &self.output_prefix {
      builder = builder.raw_line(line);
    }
    self.setup.call(builder)
  }

  pub fn gen_bindings(&self) -> BoxResult<Bindings> {
    let builder = self.builder();
    let args = builder.command_line_flags();
    eprintln!("bindgen args:\n\t{}", args.join(" \\\n\t"));

    Ok(builder.generate().or_else(|_| {
      let header = self.header.to_str().unwrap();
      Err(format!("Failed to generate bindings for header {}", header))
    })?)
  }

  pub fn write_bindings(&self, bindings: Bindings) -> BoxResult<PathBuf> {
    let path = self.output_path();
    {
      let mut file = File::create(&path)?;
      bindings.write(Box::new(&mut file))?;
      for line in &self.output_suffix {
        file.write_all(line.as_bytes())?;
        file.write_all("\n".as_bytes())?;
      }
    }
    self.postproc.call(path)
  }

  pub fn output_path(&self) -> PathBuf {
    self.output_dir.join(&self.output_name)
  }

  pub fn sol_inc_dir(&self) -> PathBuf {
    self.sol_root_dir.join("sdk/bpf/c/inc")
  }

  pub fn sol_sdk_header(&self) -> PathBuf {
    self.sol_inc_dir().join("solana_sdk.h")
  }

  pub fn bpf_llvm_root(&self) -> PathBuf {
    self.sol_root_dir.join("sdk/bpf/dependencies/bpf-tools/llvm")
  }

  pub fn bpf_llvm_inc_dir(&self) -> PathBuf {
    self.bpf_llvm_root().join("lib/clang/12.0.1/include")
  }

  pub fn criterion_inc_dir(&self) -> PathBuf {
    self.sol_root_dir.join("dependencies/criterion/include")
  }

  pub fn std(&self) -> String {
    let ext = self.header.extension().unwrap().to_str().unwrap();
    match &self.std {
      Some(val) => val.clone(),
      None => match ext {
        "h" | "c" => "c17",
        "hpp" | "cpp" => "c++17",
        _ => panic!("Unknown extension '.{}'", ext)
      }.to_string(),
    }
  }

  pub fn clang_args(&self) -> Vec<String> {
    // TODO Read variables from src_dir/../bpf.mk

    let mut args = vec![
      clang::std(&self.std()),
      // #include <myprog/myutils.h>
      clang::include(&self.prog_src_dir),
      // #include <solana_sdk.h>
      clang::isystem(&self.sol_inc_dir()),
    ];

    match &self.sysroot {
      Some(path) => {
        args.push(clang::sysroot(&path));
      },
      None => {
        // Use solana llvm stdlib headers by default.
        args.push(clang::sysroot(&self.bpf_llvm_root()));
        args.push(clang::isystem(&self.bpf_llvm_inc_dir()));
      }
    }

    if self.is_sol_test {
      // Mirror criterion test build config from bpf.mk.
      args.push(clang::define("SOL_TEST"));
      args.push(clang::isystem(&self.criterion_inc_dir()))
    }
    else if self.define_bpf {
      // Headers may conditionally include solana_sdk.h vs stdint.h
      // based on __bpf__ or SOL_TEST definitions from bpf.mk.
      // Use solana_sdk typedefs by default.
      args.push(clang::define("__bpf__"));
    }

    if self.nobuiltin {
      // bpf.mk default
      args.push(clang::flag("no-builtin"));
    }

    if self.keep_inline_funcs {
      // Required for Builder::generate_inline_functions().
      args.push(clang::flag("no-inline-functions"));
      // args.push(clang::flag("keep-inline-functions"));
    }

    if self.wall {
      args.push(clang::warn("all"));
    }
    if self.werror {
      args.push(clang::warn("error"));
    }
    if self.wextra {
      args.push(clang::warn("extra"));
    }
    if self.wconversion {
      args.push(clang::warn("conversion"));
    }

    args
  }

  /// Make derive(Debug) failures fatal.
  pub fn derive_debug(&mut self) {
    self.parser.derive_all_from("Debug");
    self.setup.push(|builder| {
      builder.derive_debug(false)
    })
  }

  /// Make derive(Copy) failures fatal.
  pub fn derive_copy(&mut self) {
    self.parser.derive_all_from("Copy");
    self.parser.derive_all_from("Clone");
    self.setup.push(|builder| {
      builder.derive_copy(false)
    })
  }

  pub fn add_module_attr(&mut self, attr: &str) {
    self.output_prefix.insert(0, format!("#![{}]", attr));
  }

  pub fn import(&mut self, module: &str) {
    self.output_prefix.push(format!("use {};", module));
  }

  pub fn sed(&mut self, cmd: &str) {
    let cmd = cmd.to_owned();
    self.postproc.push(move |path| -> BoxResult<PathBuf> {
      let args = ["-i", "", &cmd, path.to_str().unwrap()];
      Command::new("sed").args(args).output()?;
      Ok(path)
    });
  }

}
