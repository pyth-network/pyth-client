//this is auto generated by build_bpf.sh
mod c_oracle_header;
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::entrypoint::{deserialize, ProgramResult};
use solana_program::msg;
use solana_program::{account_info::AccountInfo, pubkey::Pubkey, program_error::PrintProgramError};

mod bindings;
mod error;
use bindings::{
    cmd_hdr, cmd_upd_price, command_t_e_cmd_add_mapping, command_t_e_cmd_add_price,
    command_t_e_cmd_add_product, command_t_e_cmd_add_publisher, command_t_e_cmd_del_publisher,
    command_t_e_cmd_init_mapping, command_t_e_cmd_init_price, command_t_e_cmd_set_min_pub,
    command_t_e_cmd_upd_price, command_t_e_cmd_upd_price_no_fail_on_error, command_t_e_cmd_agg_price,
    command_t_e_cmd_upd_product
};
use error::OracleError;

#[link(name = "cpyth")]
extern "C" {
    fn c_entrypoint(input: *mut u8) -> u64;
}

#[no_mangle]
pub extern "C" fn entrypoint(input: *mut u8) -> u64 {

    let (_program_id, _accounts, instruction_data) = unsafe { deserialize(input) };

    match pre_process(_program_id, &_accounts, instruction_data) {
        Err(error) => return error.into(),
        _ => {}
    }

    let c_ret_val = unsafe{c_entrypoint(input)};
    if c_ret_val == c_oracle_header::SUCCESSFULLY_UPDATED_AGGREGATE{
        return 0;
    } else {
        return c_ret_val;
    }

}

pub fn pre_process(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    msg!("Pyth oracle contract");

    let instruction_header: cmd_hdr = cmd_hdr::try_from_slice(&instruction_data[..8])?;
    let instruction_id: u32 = instruction_header
        .cmd_
        .try_into()
        .map_err(|_| OracleError::Generic)?;
    match instruction_id {
        command_t_e_cmd_upd_price_no_fail_on_error => {
            let instruction: cmd_upd_price =
                cmd_upd_price::try_from_slice(&instruction_data).unwrap();
            msg!(
                "Update price no fail on error: price={:}, conf={:}, status={:}",
                instruction.price_,
                instruction.conf_,
                instruction.status_
            );
        }
        command_t_e_cmd_upd_price => {
            let instruction: cmd_upd_price =
                cmd_upd_price::try_from_slice(&instruction_data).unwrap();
            msg!(
                "Update price: price={:}, conf={:}, status={:}",
                instruction.price_,
                instruction.conf_,
                instruction.status_
            );
        }
        command_t_e_cmd_agg_price => {
            let instruction: cmd_upd_price =
            cmd_upd_price::try_from_slice(&instruction_data).unwrap();
            msg!(
                "Update price: price={:}, conf={:}, status={:}",
                instruction.price_,
                instruction.conf_,
                instruction.status_
            );
        }
        command_t_e_cmd_add_mapping => {
            msg!("Add mapping");
        }
        command_t_e_cmd_add_price => {
            msg!("Add price");
        }
        command_t_e_cmd_add_product => {
            msg!("Add product")
        }
        command_t_e_cmd_add_publisher => {
            msg!("Add publisher")
        }
        command_t_e_cmd_del_publisher => {
            msg!("Delete publisher")
        }
        command_t_e_cmd_init_price => {
            msg!("Initialize price")
        }
        command_t_e_cmd_init_mapping => {
            msg!("Initialize mapping account");
        }

        command_t_e_cmd_set_min_pub =>{
            msg!("Set minimum number of publishers");
        }
        command_t_e_cmd_upd_product =>{
            msg!("Update product");
        }
        _ => {
            msg!("Unrecognized instruction");
            return Err(OracleError::Generic.into());
        }
    }
    Ok(())

    // const instruction_id : u32 = instruction_header.cmd_.try_into();

    // if (command_t_e_cmd_upd_price_no_fail_on_error == instruction_header.cmd_.try_into().unwrap() || command_t_e_cmd_upd_price == instruction_header.cmd_.try_into().unwrap()){
    //     let instruction :cmd_upd_price = cmd_upd_price::try_from_slice(&instruction_data).unwrap();
    //     msg!("Price : {:}, Conf : {:}, Status: {:}", instruction.price_, instruction.conf_, instruction.status_);
    // }
}

solana_program::custom_heap_default!();
solana_program::custom_panic_default!();
// { "jsonrpc": "2.0", "method": "get_product_list", "id" : 1}
// {  "jsonrpc": "2.0", "method": "update_price","params" : {"account": "2xUwgsbspTR7i8WcDPniczR8Ki3EytDNTfxgMKDkdhaz", "price" : 42002,"conf" : 3,"status": "trading"},"id" : 1}
